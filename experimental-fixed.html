<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¨ Waterscape Chaos Investigation - FIXED</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .experimental-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .chaos-section {
            background: linear-gradient(135deg, rgba(255,107,107,0.1), rgba(78,205,196,0.1));
            border: 2px solid rgba(255,107,107,0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .chaos-section h3 {
            color: #ff6b6b;
            margin-bottom: 15px;
        }
        
        .chaos-button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin: 10px 5px;
        }
        
        .chaos-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .parameter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        @media (max-width: 768px) {
            .parameter-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="experimental-badge">üî¨ FIXED</div>
        
        <header>
            <h1>üåä Waterscape</h1>
            <p>Chaos Investigation Studio - Fixed Integration</p>
        </header>

        <div class="content">
            <div class="controls">
                <div class="control-section">
                    <h3>üé® Color Palette</h3>
                    <div class="control-group">
                        <select id="paletteSelect">
                            <option value="vibrant">Vibrant</option>
                            <option value="pastel">Pastel</option>
                            <option value="earth">Earth Tones</option>
                            <option value="ocean">Ocean</option>
                            <option value="sunset">Sunset</option>
                            <option value="forest">Forest</option>
                            <option value="monochrome">Monochrome</option>
                        </select>
                    </div>
                    <div id="colorPalette" class="color-palette"></div>
                </div>

                <div class="control-section">
                    <h3>üéÆ Generation</h3>
                    
                    <div class="control-group">
                        <label for="brushCount">Brush Count:</label>
                        <input type="range" id="brushCount" min="3" max="25" value="12">
                        <span id="brushCountValue">12</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="layersPerBrush">Layers per Brush:</label>
                        <input type="range" id="layersPerBrush" min="5" max="50" value="25">
                        <span id="layersPerBrushValue">25</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="brushSize">Brush Size:</label>
                        <input type="range" id="brushSize" min="30" max="150" value="90">
                        <span id="brushSizeValue">90</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üåÄ Watercolor FX</h3>
                    
                    <div class="control-group">
                        <label for="edgeComplexity">Edge Complexity:</label>
                        <input type="range" id="edgeComplexity" min="1" max="10" value="4">
                        <span id="edgeComplexityValue">4</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="deformStrength">Blur Amount:</label>
                        <input type="range" id="deformStrength" min="0.1" max="1.0" step="0.1" value="0.3">
                        <span id="deformStrengthValue">0.3</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="opacity">Layer Opacity:</label>
                        <input type="range" id="opacity" min="1" max="20" value="8">
                        <span id="opacityValue">8</span>
                    </div>
                </div>

                <!-- CHAOS INVESTIGATION SECTION -->
                <div class="chaos-section">
                    <h3>üî¨ Chaos Investigation System</h3>
                    
                    <div class="control-group">
                        <label for="chaosMethod">Investigation Method:</label>
                        <select id="chaosMethod">
                            <option value="1">üåÄ Lorenz Attractors</option>
                            <option value="2">üåä Flow Field Followers</option>
                            <option value="3">üåø Fractal Branches</option>
                            <option value="4">üî¨ Cellular Automata</option>
                            <option value="5">üå∏ Fibonacci Spirals</option>
                            <option value="6">‚öóÔ∏è Reaction-Diffusion</option>
                            <option value="0">üé≠ Hybrid Multi-Method</option>
                        </select>
                    </div>
                    
                    <div class="parameter-grid">
                        <div class="control-group">
                            <label for="chaosIntensity">üå™Ô∏è Chaos Intensity:</label>
                            <input type="range" id="chaosIntensity" min="0.1" max="2.0" step="0.1" value="0.7">
                            <span id="chaosIntensityValue">0.7</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="chaosDensity">üï∏Ô∏è Pattern Density:</label>
                            <input type="range" id="chaosDensity" min="0.1" max="1.5" step="0.1" value="0.5">
                            <span id="chaosDensityValue">0.5</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="chaosEvolution">‚è∞ Temporal Evolution:</label>
                            <input type="range" id="chaosEvolution" min="0.0" max="1.0" step="0.1" value="0.3">
                            <span id="chaosEvolutionValue">0.3</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="chaosComplexity">üß¨ Structural Complexity:</label>
                            <input type="range" id="chaosComplexity" min="0.1" max="1.0" step="0.1" value="0.6">
                            <span id="chaosComplexityValue">0.6</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="chaosOrganic">üçÉ Organic Factor:</label>
                            <input type="range" id="chaosOrganic" min="0.1" max="1.0" step="0.1" value="0.8">
                            <span id="chaosOrganicValue">0.8</span>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button id="generateChaos" class="chaos-button">üî¨ Generate with Chaos</button>
                        <button id="generateNormal" class="chaos-button" style="background: linear-gradient(45deg, #95a5a6, #7f8c8d);">üé® Generate Normal</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>‚öôÔ∏è Settings</h3>
                    
                    <div class="control-group">
                        <label for="randomSeed">Random Seed:</label>
                        <input type="number" id="randomSeed" value="42">
                    </div>
                    
                    <div class="control-group">
                        <label for="backgroundType">Background:</label>
                        <select id="backgroundType">
                            <option value="white">White</option>
                            <option value="paper">Paper Texture</option>
                            <option value="gradient">Gradient</option>
                        </select>
                    </div>
                    
                    <div class="action-buttons">
                        <button onclick="generateWaterscape()">Generate</button>
                        <button onclick="savePNG()">Export PNG</button>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <div id="canvasWrapper"></div>
                
                <div class="metadata">
                    <p>v2.1 ‚Ä¢ Chaos Investigation Algorithm</p>
                    <p>800 √ó 600px</p>
                    <p>Generated with <span id="currentPaletteInfo">vibrant</span> palette ‚Ä¢ <span id="layerCountInfo">300</span> total layers</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Color Picker Overlay -->
    <div id="colorPickerOverlay" class="color-picker-overlay">
        <div class="color-picker-modal">
            <h3>Edit Color</h3>
            
            <div class="color-preview" id="colorPreview"></div>
            
            <div class="color-inputs">
                <input type="color" id="colorInput">
                <input type="text" id="hexInput" placeholder="#FF6B6B">
            </div>
            
            <div class="preset-colors" id="presetColors"></div>
            
            <div class="color-picker-actions">
                <button onclick="applyColor()">Apply</button>
                <button onclick="closeColorPicker()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Load p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    
    <!-- INTEGRATED WATERSCAPE + CHAOS SYSTEM -->
    <script>
        console.log("üé® Integrated Waterscape + Chaos Investigation System v2.1");

        // =================== GLOBAL VARIABLES ===================
        
        // Color palettes
        let palettes = {
            vibrant: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'],
            pastel: ['#FFB3BA', '#BAFFC9', '#BAE1FF', '#FFFFBA', '#FFDFBA', '#E0BBE4', '#957DAD', '#D291BC'],
            earth: ['#8B4513', '#D2691E', '#CD853F', '#DEB887', '#F4A460', '#D2B48C', '#BC8F8F', '#A0522D'],
            ocean: ['#006994', '#4A90A4', '#83C5BE', '#7FCDCD', '#7FB3D3', '#5D737E', '#3E8E7E', '#1F4E79'],
            sunset: ['#FF4B2B', '#FF416C', '#FFA07A', '#FFB347', '#FFD700', '#FF6347', '#FF69B4', '#FF1493'],
            forest: ['#228B22', '#32CD32', '#7CFC00', '#9ACD32', '#90EE90', '#98FB98', '#00FF7F', '#3CB371'],
            monochrome: ['#2C3E50', '#34495E', '#7F8C8D', '#95A5A6', '#BDC3C7', '#D5DBDB', '#85929E', '#566573']
        };

        const presetColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
            '#FFB3BA', '#BAFFC9', '#BAE1FF', '#FFFFBA', '#FFDFBA', '#E0BBE4', '#957DAD', '#D291BC'
        ];

        let currentPalette = 'vibrant';
        let editingColorIndex = -1;
        let canvas;
        
        // Base watercolor parameters
        let params = {
            brushCount: 12,
            layersPerBrush: 25,
            brushSize: 90,
            edgeComplexity: 4,
            deformStrength: 0.3,
            opacity: 8,
            randomSeed: 42,
            backgroundType: 'white'
        };
        
        // Chaos investigation parameters
        let chaosParams = {
            method: 1,
            intensity: 0.7,
            density: 0.5,
            evolution: 0.3,
            complexity: 0.6,
            organicFactor: 0.8,
            enabled: false
        };
        
        // Chaos system objects
        let chaosFlowField;
        
        // =================== CHAOS MATHEMATICS ===================
        
        class LorenzAttractor {
            constructor(sigma = 10, rho = 28, beta = 8/3) {
                this.sigma = sigma;
                this.rho = rho;
                this.beta = beta;
                this.x = 1;
                this.y = 1;
                this.z = 1;
                this.dt = 0.01;
            }
            
            step() {
                const dx = this.sigma * (this.y - this.x) * this.dt;
                const dy = (this.x * (this.rho - this.z) - this.y) * this.dt;
                const dz = (this.x * this.y - this.beta * this.z) * this.dt;
                
                this.x += dx;
                this.y += dy;
                this.z += dz;
                
                return { x: this.x, y: this.y, z: this.z };
            }
        }

        class ChaosFlowField {
            constructor(resolution = 20) {
                this.resolution = resolution;
                this.cols = Math.floor(800 / resolution) + 1;
                this.rows = Math.floor(600 / resolution) + 1;
                this.field = [];
                this.time = 0;
                this.generateField();
            }
            
            generateField() {
                this.field = [];
                for (let x = 0; x < this.cols; x++) {
                    this.field[x] = [];
                    for (let y = 0; y < this.rows; y++) {
                        let angle = noise(x * 0.1, y * 0.1, this.time * 0.01) * TWO_PI * 4;
                        angle += noise(x * 0.02, y * 0.02, this.time * 0.005) * TWO_PI * 2;
                        this.field[x][y] = angle;
                    }
                }
            }
            
            getFlow(x, y) {
                const col = Math.floor(constrain(x / this.resolution, 0, this.cols - 1));
                const row = Math.floor(constrain(y / this.resolution, 0, this.rows - 1));
                return this.field[col][row];
            }
            
            update() {
                this.time += 1;
                this.generateField();
            }
        }
        
        // =================== CHAOS SEEPAGE METHODS ===================
        
        function createLorenzSeepage(centerX, centerY, baseRadius) {
            let attractor = new LorenzAttractor();
            let streamPoints = [];
            let streamCount = Math.floor(random(3, 8));
            
            for (let s = 0; s < streamCount; s++) {
                let stream = [];
                attractor.x = random(-2, 2);
                attractor.y = random(-2, 2);
                attractor.z = random(20, 30);
                
                for (let i = 0; i < 50; i++) {
                    let point = attractor.step();
                    let x = centerX + (point.x * baseRadius * 0.1);
                    let y = centerY + (point.y * baseRadius * 0.1);
                    
                    x += noise(i * 0.3, s * 100) * 20 - 10;
                    y += noise(i * 0.3 + 1000, s * 100) * 20 - 10;
                    
                    stream.push({ x, y, z: point.z });
                }
                streamPoints.push(stream);
            }
            
            return streamPoints;
        }
        
        function createFlowFieldSeepage(centerX, centerY, baseRadius) {
            let followers = [];
            let followerCount = Math.floor(random(5, 12));
            
            for (let f = 0; f < followerCount; f++) {
                let follower = {
                    x: centerX + random(-baseRadius * 0.3, baseRadius * 0.3),
                    y: centerY + random(-baseRadius * 0.3, baseRadius * 0.3),
                    trail: []
                };
                
                for (let step = 0; step < random(20, 60); step++) {
                    let flowAngle = chaosFlowField.getFlow(follower.x, follower.y);
                    let speed = 1 + noise(step * 0.2, f * 50) * 2;
                    let chaosAngle = noise(follower.x * 0.01, follower.y * 0.01) * PI * 0.4;
                    
                    follower.x += cos(flowAngle + chaosAngle) * speed;
                    follower.y += sin(flowAngle + chaosAngle) * speed;
                    
                    follower.trail.push({ x: follower.x, y: follower.y });
                    
                    if (dist(follower.x, follower.y, centerX, centerY) > baseRadius * 2) break;
                }
                
                followers.push(follower.trail);
            }
            
            return followers;
        }
        
        function createFractalSeepage(centerX, centerY, baseRadius) {
            let branches = [];
            let branchCount = Math.floor(random(2, 6));
            
            for (let b = 0; b < branchCount; b++) {
                let angle = (TWO_PI / branchCount) * b + random(-PI/4, PI/4);
                let length = baseRadius * random(0.5, 1.2);
                
                let startX = centerX + cos(angle) * baseRadius * 0.2;
                let startY = centerY + sin(angle) * baseRadius * 0.2;
                
                let branch = createBranch(startX, startY, angle, length, 0, 3);
                branches.push(branch);
            }
            
            return branches;
        }
        
        function createBranch(x, y, angle, length, generation, maxGen) {
            let points = [];
            let segments = Math.floor(length / 3);
            let currentX = x;
            let currentY = y;
            let currentAngle = angle;
            
            for (let i = 0; i < segments; i++) {
                let t = i / segments;
                let chaosForce = noise(currentX * 0.01, currentY * 0.01, generation * 0.5) * PI * 0.3;
                let turbulence = noise(currentX * 0.05, currentY * 0.05) * 0.4;
                
                currentAngle += chaosForce + (turbulence - 0.2);
                
                let stepLength = length / segments;
                currentX += cos(currentAngle) * stepLength;
                currentY += sin(currentAngle) * stepLength;
                
                points.push({ x: currentX, y: currentY, width: length * (1 - t * 0.7) });
                
                // Create micro-branches
                if (random() < 0.3 && i > 2) {
                    let branchAngle = currentAngle + random(-PI/3, PI/3);
                    let branchLength = stepLength * random(0.5, 1.5);
                    let branchX = currentX + cos(branchAngle) * branchLength;
                    let branchY = currentY + sin(branchAngle) * branchLength;
                    points.push({x: branchX, y: branchY, width: 1});
                }
            }
            
            return points;
        }
        
        function createFibonacciSeepage(centerX, centerY, baseRadius) {
            let spirals = [];
            let spiralCount = Math.floor(random(2, 5));
            
            for (let s = 0; s < spiralCount; s++) {
                let spiral = [];
                let points = Math.floor(random(30, 80));
                let goldenAngle = PI * (3 - Math.sqrt(5));
                
                for (let i = 0; i < points; i++) {
                    let r = Math.sqrt(i) * baseRadius * 0.1;
                    let theta = i * goldenAngle + s * PI * 0.5;
                    
                    r *= 1 + noise(i * 0.1, s * 50) * 0.8;
                    theta += noise(i * 0.2, s * 50) * 0.4;
                    
                    let x = centerX + r * cos(theta);
                    let y = centerY + r * sin(theta);
                    
                    spiral.push({ x, y });
                }
                spirals.push(spiral);
            }
            
            return spirals;
        }
        
        function createCellularSeepage(centerX, centerY, baseRadius) {
            let grid = [];
            let gridSize = 5;
            let cols = Math.floor(baseRadius * 2 / gridSize);
            let rows = Math.floor(baseRadius * 2 / gridSize);
            
            // Initialize grid
            for (let x = 0; x < cols; x++) {
                grid[x] = [];
                for (let y = 0; y < rows; y++) {
                    let distance = dist(x * gridSize, y * gridSize, cols * gridSize / 2, rows * gridSize / 2);
                    grid[x][y] = distance < baseRadius * 0.8 ? 1 : 0;
                }
            }
            
            // Apply cellular automata rules
            for (let generation = 0; generation < 3; generation++) {
                let newGrid = JSON.parse(JSON.stringify(grid));
                
                for (let x = 1; x < cols - 1; x++) {
                    for (let y = 1; y < rows - 1; y++) {
                        let neighbors = 0;
                        for (let nx = -1; nx <= 1; nx++) {
                            for (let ny = -1; ny <= 1; ny++) {
                                if (grid[x + nx][y + ny]) neighbors++;
                            }
                        }
                        
                        let growthChance = map(neighbors, 0, 9, 0.1, 0.8);
                        growthChance *= noise(x * 0.3, y * 0.3, generation * 0.5);
                        
                        if (random() < growthChance) {
                            newGrid[x][y] = 1;
                        }
                    }
                }
                grid = newGrid;
            }
            
            // Convert to points
            let points = [];
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    if (grid[x][y]) {
                        points.push({
                            x: centerX - cols * gridSize / 2 + x * gridSize,
                            y: centerY - rows * gridSize / 2 + y * gridSize
                        });
                    }
                }
            }
            
            return [points];
        }
        
        function createReactionDiffusionSeepage(centerX, centerY, baseRadius) {
            let patterns = [];
            let waveCount = Math.floor(random(3, 7));
            
            for (let w = 0; w < waveCount; w++) {
                let wave = [];
                let startAngle = random(TWO_PI);
                let amplitude = baseRadius * random(0.2, 0.6);
                
                for (let i = 0; i < 60; i++) {
                    let t = i / 60;
                    let angle = startAngle + t * PI * 2;
                    
                    let reactionTerm = sin(i * 0.5) * cos(i * 0.3);
                    let diffusionTerm = noise(i * 0.2, w * 100) * 2 - 1;
                    
                    let r = baseRadius * 0.3 + amplitude * (reactionTerm + diffusionTerm * 0.5);
                    
                    let x = centerX + r * cos(angle);
                    let y = centerY + r * sin(angle);
                    
                    wave.push({ x, y });
                }
                patterns.push(wave);
            }
            
            return patterns;
        }
        
        // =================== CHAOS INVESTIGATION SYSTEM ===================
        
        function investigateChaosSeepage(centerX, centerY, baseRadius, method = null) {
            if (!method) method = chaosParams.method;
            
            let seepagePatterns = [];
            
            switch (method) {
                case 1:
                    seepagePatterns = createLorenzSeepage(centerX, centerY, baseRadius);
                    break;
                case 2:
                    seepagePatterns = createFlowFieldSeepage(centerX, centerY, baseRadius);
                    break;
                case 3:
                    seepagePatterns = createFractalSeepage(centerX, centerY, baseRadius);
                    break;
                case 4:
                    seepagePatterns = createCellularSeepage(centerX, centerY, baseRadius);
                    break;
                case 5:
                    seepagePatterns = createFibonacciSeepage(centerX, centerY, baseRadius);
                    break;
                case 6:
                    seepagePatterns = createReactionDiffusionSeepage(centerX, centerY, baseRadius);
                    break;
                default:
                    // Hybrid approach - combine multiple methods
                    let methods = [1, 2, 3, 4, 5, 6];
                    let selectedMethods = [];
                    for (let i = 0; i < 3; i++) {
                        selectedMethods.push(methods[Math.floor(random(methods.length))]);
                    }
                    
                    for (let m of selectedMethods) {
                        seepagePatterns = seepagePatterns.concat(investigateChaosSeepage(centerX, centerY, baseRadius, m));
                    }
                    break;
            }
            
            return seepagePatterns;
        }
        
        // =================== WATERCOLOR FUNCTIONS ===================
        
        function deformPolygon(vertices, complexity, strength) {
            let result = JSON.parse(JSON.stringify(vertices));
            
            for (let round = 0; round < complexity; round++) {
                let newVertices = [];
                let currentStrength = strength * (1 / (round + 1));
                
                for (let i = 0; i < result.length; i++) {
                    let current = result[i];
                    let next = result[(i + 1) % result.length];
                    
                    newVertices.push(current);
                    
                    let midX = (current.x + next.x) / 2;
                    let midY = (current.y + next.y) / 2;
                    
                    let deformX = (Math.random() - 0.5) * currentStrength * 40;
                    let deformY = (Math.random() - 0.5) * currentStrength * 40;
                    
                    newVertices.push({
                        x: midX + deformX,
                        y: midY + deformY
                    });
                }
                
                result = newVertices;
            }
            
            return result;
        }
        
        function createWatercolorBrush() {
            try {
                let x = random(width * 0.2, width * 0.8);
                let y = random(height * 0.2, height * 0.8);
                let size = random(params.brushSize * 0.7, params.brushSize * 1.3);
                let sides = int(random(6, 10));
                
                let colorIndex = int(random(palettes[currentPalette].length));
                let baseColor = palettes[currentPalette][colorIndex];
                
                let r = parseInt(baseColor.slice(1, 3), 16);
                let g = parseInt(baseColor.slice(3, 5), 16);
                let b = parseInt(baseColor.slice(5, 7), 16);
                
                r = constrain(r + random(-20, 20), 0, 255);
                g = constrain(g + random(-20, 20), 0, 255);
                b = constrain(b + random(-20, 20), 0, 255);
                
                let basePolygon = [];
                for (let i = 0; i < sides; i++) {
                    let angle = (TWO_PI / sides) * i;
                    let vx = x + cos(angle) * size;
                    let vy = y + sin(angle) * size;
                    basePolygon.push({x: vx, y: vy});
                }
                
                basePolygon = deformPolygon(basePolygon, params.edgeComplexity, params.deformStrength);
                
                // Create chaos seepage if enabled
                let seepagePatterns = [];
                if (chaosParams.enabled) {
                    seepagePatterns = investigateChaosSeepage(x, y, size);
                }
                
                return {
                    basePolygon: basePolygon,
                    seepagePatterns: seepagePatterns,
                    r: r,
                    g: g,
                    b: b,
                    x: x,
                    y: y,
                    size: size
                };
            } catch (error) {
                console.error("Error creating brush:", error);
                return null;
            }
        }
        
        function drawWatercolorLayer(brush, layerIndex) {
            try {
                if (!brush) return;
                
                // Create slight variation for this layer
                let layerPolygon = brush.basePolygon.map(v => ({
                    x: v.x + random(-2, 2),
                    y: v.y + random(-2, 2)
                }));
                
                layerPolygon = deformPolygon(layerPolygon, 2, params.deformStrength * 0.5);
                
                // Draw main shape
                fill(brush.r, brush.g, brush.b, params.opacity);
                noStroke();
                
                beginShape();
                for (let v of layerPolygon) {
                    vertex(v.x, v.y);
                }
                endShape(CLOSE);
                
                // Draw chaos seepage patterns as thin lines
                if (chaosParams.enabled && brush.seepagePatterns && brush.seepagePatterns.length > 0) {
                    let seepageOpacity = params.opacity * 0.4 * chaosParams.density;
                    
                    for (let pattern of brush.seepagePatterns) {
                        if (pattern && pattern.length > 1) {
                            let lineWeight = random(0.5, 2.5) * chaosParams.complexity;
                            let lineOpacity = seepageOpacity * random(0.3, 1.2);
                            
                            stroke(brush.r, brush.g, brush.b, lineOpacity);
                            strokeWeight(lineWeight);
                            noFill();
                            
                            beginShape();
                            for (let point of pattern) {
                                if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                                    let microChaosX = noise(layerIndex * 0.1, point.x * 0.01) * 3 - 1.5;
                                    let microChaosY = noise(layerIndex * 0.1 + 500, point.y * 0.01) * 3 - 1.5;
                                    
                                    vertex(point.x + microChaosX, point.y + microChaosY);
                                }
                            }
                            endShape();
                        }
                    }
                    noStroke();
                }
                
            } catch (error) {
                console.error("Error drawing layer:", error);
            }
        }
        
        function drawBackground() {
            switch (params.backgroundType) {
                case 'white':
                    background(255);
                    break;
                case 'paper':
                    background(252, 248, 240);
                    noStroke();
                    for (let i = 0; i < 200; i++) {
                        fill(240, 235, 220, random(10, 30));
                        circle(random(width), random(height), random(0.5, 2));
                    }
                    break;
                case 'gradient':
                    for (let y = 0; y < height; y++) {
                        let alpha = map(y, 0, height, 0, 1);
                        let r = lerp(255, 240, alpha);
                        let g = lerp(255, 248, alpha);
                        let b = lerp(255, 255, alpha);
                        stroke(r, g, b);
                        line(0, y, width, y);
                    }
                    break;
                default:
                    background(255);
            }
        }
        
        function generateWaterscape() {
            try {
                console.log("üé® Generating waterscape...", params);
                
                randomSeed(params.randomSeed);
                
                background(255);
                drawBackground();
                
                let brushes = [];
                for (let i = 0; i < params.brushCount; i++) {
                    let brush = createWatercolorBrush();
                    if (brush) {
                        brushes.push(brush);
                    }
                }
                
                console.log(`‚ú® Created ${brushes.length} brushes`);
                
                if (brushes.length === 0) {
                    throw new Error("No brushes created");
                }
                
                // Draw layers
                for (let layer = 0; layer < params.layersPerBrush; layer++) {
                    // Update chaos evolution
                    chaosParams.evolution = layer / params.layersPerBrush;
                    
                    // Update flow field occasionally
                    if (chaosFlowField && layer % 10 === 0) {
                        chaosFlowField.update();
                    }
                    
                    for (let brush of brushes) {
                        drawWatercolorLayer(brush, layer);
                    }
                }
                
                updateMetadata();
                
                console.log("üé® Generation complete!");
                
            } catch (error) {
                console.error('‚ùå Generation error:', error);
                
                background(255);
                
                for (let i = 0; i < 5; i++) {
                    let colorIndex = int(random(palettes[currentPalette].length));
                    let baseColor = palettes[currentPalette][colorIndex];
                    let r = parseInt(baseColor.slice(1, 3), 16);
                    let g = parseInt(baseColor.slice(3, 5), 16);
                    let b = parseInt(baseColor.slice(5, 7), 16);
                    
                    fill(r, g, b, 30);
                    noStroke();
                    
                    let x = random(width * 0.2, width * 0.8);
                    let y = random(height * 0.2, height * 0.8);
                    let size = random(50, 150);
                    
                    circle(x, y, size);
                }
                
                updateMetadata();
            }
        }
        
        // =================== UI FUNCTIONS ===================
        
        function updateMetadata() {
            const totalLayers = params.brushCount * params.layersPerBrush;
            document.getElementById('currentPaletteInfo').textContent = currentPalette;
            document.getElementById('layerCountInfo').textContent = totalLayers;
        }
        
        function updateColorPalette() {
            const paletteDiv = document.getElementById('colorPalette');
            if (!paletteDiv) return;
            
            paletteDiv.innerHTML = '';
            
            palettes[currentPalette].forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                swatch.onclick = () => openColorPicker(index);
                paletteDiv.appendChild(swatch);
            });
        }
        
        function setupControls() {
            console.log("üéõÔ∏è Setting up controls...");
            
            // Palette selector
            const paletteSelect = document.getElementById('paletteSelect');
            if (paletteSelect) {
                paletteSelect.addEventListener('change', (e) => {
                    currentPalette = e.target.value;
                    updateColorPalette();
                    generateWaterscape();
                });
            }

            // Parameter controls
            Object.keys(params).forEach(param => {
                const control = document.getElementById(param);
                const valueDisplay = document.getElementById(param + 'Value');
                
                if (control && valueDisplay) {
                    control.addEventListener('input', (e) => {
                        params[param] = param === 'deformStrength' ? 
                            parseFloat(e.target.value) : 
                            parseInt(e.target.value);
                        
                        valueDisplay.textContent = 
                            param === 'deformStrength' ? 
                            params[param].toFixed(1) : 
                            params[param];
                        
                        generateWaterscape();
                    });
                }
            });

            // Background type
            const backgroundType = document.getElementById('backgroundType');
            if (backgroundType) {
                backgroundType.addEventListener('change', (e) => {
                    params.backgroundType = e.target.value;
                    generateWaterscape();
                });
            }
            
            // CHAOS CONTROLS
            const chaosControls = [
                'chaosIntensity', 'chaosDensity', 'chaosEvolution', 
                'chaosComplexity', 'chaosOrganic'
            ];
            
            chaosControls.forEach(controlId => {
                const control = document.getElementById(controlId);
                const valueDisplay = document.getElementById(controlId + 'Value');
                
                if (control && valueDisplay) {
                    control.addEventListener('input', (e) => {
                        const paramName = controlId.replace('chaos', '').toLowerCase();
                        chaosParams[paramName] = parseFloat(e.target.value);
                        valueDisplay.textContent = chaosParams[paramName].toFixed(1);
                        
                        // If chaos is enabled, regenerate
                        if (chaosParams.enabled) {
                            generateWaterscape();
                        }
                    });
                }
            });
            
            // Chaos method selector
            const methodSelect = document.getElementById('chaosMethod');
            if (methodSelect) {
                methodSelect.addEventListener('change', (e) => {
                    chaosParams.method = parseInt(e.target.value);
                    
                    if (chaosParams.enabled) {
                        generateWaterscape();
                    }
                });
            }
            
            // Chaos generation button
            const generateChaos = document.getElementById('generateChaos');
            if (generateChaos) {
                generateChaos.addEventListener('click', () => {
                    console.log("üî¨ Enabling chaos investigation mode");
                    chaosParams.enabled = true;
                    generateWaterscape();
                });
            }
            
            // Normal generation button
            const generateNormal = document.getElementById('generateNormal');
            if (generateNormal) {
                generateNormal.addEventListener('click', () => {
                    console.log("üé® Disabling chaos investigation mode");
                    chaosParams.enabled = false;
                    generateWaterscape();
                });
            }
        }
        
        // Color picker functions (simplified)
        function openColorPicker(colorIndex) {
            editingColorIndex = colorIndex;
            const currentColor = palettes[currentPalette][colorIndex];
            
            document.getElementById('colorInput').value = currentColor;
            document.getElementById('hexInput').value = currentColor;
            document.getElementById('colorPreview').style.backgroundColor = currentColor;
            
            document.getElementById('colorPickerOverlay').style.display = 'flex';
        }
        
        function closeColorPicker() {
            document.getElementById('colorPickerOverlay').style.display = 'none';
            editingColorIndex = -1;
        }
        
        function applyColor() {
            if (editingColorIndex >= 0) {
                const newColor = document.getElementById('colorInput').value;
                palettes[currentPalette][editingColorIndex] = newColor;
                updateColorPalette();
                generateWaterscape();
                closeColorPicker();
            }
        }
        
        // =================== P5.JS SETUP ===================
        
        function setup() {
            try {
                console.log("üöÄ Setting up canvas...");
                canvas = createCanvas(800, 600);
                canvas.parent('canvasWrapper');
                
                // Initialize chaos flow field
                chaosFlowField = new ChaosFlowField(15);
                
                console.log("‚úÖ Canvas created successfully");
                
                setTimeout(() => {
                    setupControls();
                    updateColorPalette();
                    generateWaterscape();
                }, 200);
                
            } catch (error) {
                console.error('‚ùå Setup error:', error);
            }
        }
        
        function generateNew() {
            console.log("üîÑ Generate new called");
            generateWaterscape();
        }
        
        function savePNG() {
            try {
                if (canvas) {
                    console.log("üíæ Exporting PNG...");
                    saveCanvas(canvas, `waterscape_chaos_${Date.now()}`, 'png');
                }
            } catch (error) {
                console.error('‚ùå Export error:', error);
                alert('Error saving image. Please try again.');
            }
        }
        
        function draw() {
            // Static generation
        }
        
        // Error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('‚ùå JavaScript Error:', msg, 'at line', lineNo);
            return false;
        };
        
        console.log("‚úÖ Integrated Waterscape + Chaos Investigation System loaded successfully");
    </script>
</body>
</html>