<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waterscape - Enhanced Watercolor Art</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            gap: 20px;
            padding: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            width: 350px;
            height: fit-content;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: 600;
        }

        .control-item {
            margin-bottom: 12px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
            font-weight: 500;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .control-item select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        .control-item select:focus {
            border-color: #667eea;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.secondary {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .button.secondary:hover {
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        .canvas-wrapper {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            background: white;
        }

        .value-display {
            display: inline-block;
            color: #667eea;
            font-weight: 600;
            font-size: 12px;
            margin-left: 8px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .color-swatch {
            width: 100%;
            height: 30px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.05);
            border-color: #667eea;
        }

        .color-swatch.active {
            border-color: #667eea;
            border-width: 3px;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 28px;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
                padding: 10px;
            }
            .controls {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3 style="text-align: center; margin-bottom: 20px; color: #667eea;">Enhanced Waterscape</h3>
        
        <div class="control-group">
            <h3>Color Palette</h3>
            <div class="color-palette" id="colorPalette"></div>
            <select id="paletteSelect">
                <option value="vibrant">Vibrant</option>
                <option value="pastel">Pastel</option>
                <option value="earth">Earth Tones</option>
                <option value="ocean">Ocean</option>
                <option value="sunset">Sunset</option>
                <option value="forest">Forest</option>
                <option value="monochrome">Monochrome</option>
            </select>
        </div>

        <div class="control-group">
            <h3>Watercolor Parameters</h3>
            
            <div class="control-item">
                <label for="brushCount">Brush Count: <span class="value-display" id="brushCountValue">15</span></label>
                <input type="range" id="brushCount" min="5" max="30" value="15">
            </div>

            <div class="control-item">
                <label for="layersPerBrush">Layers per Brush: <span class="value-display" id="layersPerBrushValue">50</span></label>
                <input type="range" id="layersPerBrush" min="20" max="100" value="50">
            </div>

            <div class="control-item">
                <label for="brushSize">Brush Size: <span class="value-display" id="brushSizeValue">120</span></label>
                <input type="range" id="brushSize" min="50" max="200" value="120">
            </div>

            <div class="control-item">
                <label for="recursionDepth">Edge Detail: <span class="value-display" id="recursionDepthValue">6</span></label>
                <input type="range" id="recursionDepth" min="3" max="8" value="6">
            </div>

            <div class="control-item">
                <label for="deformStrength">Deformation: <span class="value-display" id="deformStrengthValue">0.4</span></label>
                <input type="range" id="deformStrength" min="0.1" max="0.8" step="0.1" value="0.4">
            </div>

            <div class="control-item">
                <label for="opacity">Layer Opacity: <span class="value-display" id="opacityValue">4</span></label>
                <input type="range" id="opacity" min="2" max="15" value="4">
            </div>

            <div class="control-item">
                <label for="textureIntensity">Paper Texture: <span class="value-display" id="textureIntensityValue">0.3</span></label>
                <input type="range" id="textureIntensity" min="0" max="1" step="0.1" value="0.3">
            </div>

            <div class="control-item">
                <label for="randomSeed">Random Seed: <span class="value-display" id="randomSeedValue">42</span></label>
                <input type="range" id="randomSeed" min="1" max="1000" value="42">
            </div>
        </div>

        <div class="control-group">
            <h3>Background</h3>
            <select id="backgroundType">
                <option value="white">White</option>
                <option value="paper">Paper Texture</option>
                <option value="gradient">Gradient</option>
            </select>
        </div>

        <div style="text-align: center;">
            <button class="button" onclick="generateNew()">Generate New</button>
            <button class="button secondary" onclick="savePNG()">Save PNG</button>
        </div>
    </div>

    <div class="canvas-container">
        <h1>Enhanced Waterscape</h1>
        <div class="canvas-wrapper" id="canvasWrapper"></div>
    </div>

    <script>
        // Color palettes
        const palettes = {
            vibrant: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'],
            pastel: ['#FFB3BA', '#BAFFC9', '#BAE1FF', '#FFFFBA', '#FFDFBA', '#E0BBE4', '#957DAD', '#D291BC'],
            earth: ['#8B4513', '#D2691E', '#CD853F', '#DEB887', '#F4A460', '#D2B48C', '#BC8F8F', '#A0522D'],
            ocean: ['#006994', '#4A90A4', '#83C5BE', '#7FCDCD', '#7FB3D3', '#5D737E', '#3E8E7E', '#1F4E79'],
            sunset: ['#FF4B2B', '#FF416C', '#FFA07A', '#FFB347', '#FFD700', '#FF6347', '#FF69B4', '#FF1493'],
            forest: ['#228B22', '#32CD32', '#7CFC00', '#9ACD32', '#90EE90', '#98FB98', '#00FF7F', '#3CB371'],
            monochrome: ['#2C3E50', '#34495E', '#7F8C8D', '#95A5A6', '#BDC3C7', '#D5DBDB', '#85929E', '#566573']
        };

        let currentPalette = 'vibrant';
        let params = {
            brushCount: 15,
            layersPerBrush: 50,
            brushSize: 120,
            recursionDepth: 6,
            deformStrength: 0.4,
            opacity: 4,
            textureIntensity: 0.3,
            randomSeed: 42,
            backgroundType: 'white'
        };

        let canvas;
        let textureLayer;

        // Tyler Hobbs-inspired gaussian random function
        function gaussianRandom(mean = 0, sigma = 1) {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            let z0 = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            return z0 * sigma + mean;
        }

        // Recursive polygon deformation - Tyler Hobbs technique
        function recursiveDeform(vertices, depth, baseVariance = 1.0) {
            if (depth <= 0) return vertices;
            
            let newVertices = [];
            
            for (let i = 0; i < vertices.length; i++) {
                let current = vertices[i];
                let next = vertices[(i + 1) % vertices.length];
                
                newVertices.push(current);
                
                // Calculate midpoint
                let midX = (current.x + next.x) / 2;
                let midY = (current.y + next.y) / 2;
                
                // Apply gaussian deformation based on variance
                let variance = baseVariance * current.variance * params.deformStrength;
                let deformX = gaussianRandom(0, variance * 10);
                let deformY = gaussianRandom(0, variance * 10);
                
                // Create new midpoint
                let newPoint = {
                    x: midX + deformX,
                    y: midY + deformY,
                    variance: current.variance * (0.7 + random(0.3)) // Inherit and vary
                };
                
                newVertices.push(newPoint);
            }
            
            return recursiveDeform(newVertices, depth - 1, baseVariance * 0.8);
        }

        // Create base polygon with variance
        function createBasePolygon(x, y, radius, sides) {
            let vertices = [];
            for (let i = 0; i < sides; i++) {
                let angle = (TWO_PI / sides) * i;
                let vx = x + cos(angle) * radius;
                let vy = y + sin(angle) * radius;
                
                // Assign variance - some edges sharp, some soft
                let variance = random(0.3, 1.0);
                vertices.push({x: vx, y: vy, variance: variance});
            }
            return vertices;
        }

        // Create texture mask for each layer
        function createTextureMask() {
            let mask = createGraphics(width, height);
            mask.background(255);
            
            if (params.textureIntensity > 0) {
                mask.noStroke();
                
                // Create paper texture with small spots
                let spotCount = int(params.textureIntensity * 2000);
                for (let i = 0; i < spotCount; i++) {
                    let spotSize = abs(gaussianRandom(2, 1));
                    let spotAlpha = random(50, 150);
                    mask.fill(255 - spotAlpha);
                    mask.circle(random(width), random(height), spotSize);
                }
                
                // Add some larger texture variations
                for (let i = 0; i < spotCount * 0.2; i++) {
                    let spotSize = abs(gaussianRandom(8, 3));
                    let spotAlpha = random(20, 80);
                    mask.fill(255 - spotAlpha);
                    mask.circle(random(width), random(height), spotSize);
                }
            }
            
            return mask;
        }

        // Enhanced watercolor brush using Tyler Hobbs technique
        function createWatercolorBrush() {
            let x = random(width * 0.15, width * 0.85);
            let y = random(height * 0.15, height * 0.85);
            let size = random(params.brushSize * 0.5, params.brushSize * 1.5);
            let sides = int(random(6, 12));
            
            // Pick random color from current palette
            let colorIndex = int(random(palettes[currentPalette].length));
            let baseColor = color(palettes[currentPalette][colorIndex]);
            
            // Add color variation
            let r = red(baseColor) + random(-20, 20);
            let g = green(baseColor) + random(-20, 20);
            let b = blue(baseColor) + random(-20, 20);
            
            r = constrain(r, 0, 255);
            g = constrain(g, 0, 255);
            b = constrain(b, 0, 255);
            
            // Create base polygon with variance
            let basePolygon = createBasePolygon(x, y, size, sides);
            
            // Apply initial deformation to create base shape
            basePolygon = recursiveDeform(basePolygon, params.recursionDepth);
            
            return {
                basePolygon: basePolygon,
                color: color(r, g, b),
                x: x,
                y: y,
                size: size
            };
        }

        // Draw a single watercolor layer
        function drawWatercolorLayer(brush, layerIndex) {
            // Create slight variation for this layer
            let layerPolygon = brush.basePolygon.map(vertex => ({
                x: vertex.x + gaussianRandom(0, 2),
                y: vertex.y + gaussianRandom(0, 2),
                variance: vertex.variance
            }));
            
            // Apply additional deformation for this layer
            layerPolygon = recursiveDeform(layerPolygon, 3, 0.5);
            
            // Create texture mask for this layer
            let textureMask = createTextureMask();
            
            // Create layer graphics
            let layer = createGraphics(width, height);
            layer.fill(red(brush.color), green(brush.color), blue(brush.color), params.opacity);
            layer.noStroke();
            
            layer.beginShape();
            for (let vertex of layerPolygon) {
                layer.vertex(vertex.x, vertex.y);
            }
            layer.endShape(CLOSE);
            
            // Apply texture mask
            layer.mask(textureMask);
            
            // Blend the layer onto main canvas
            image(layer, 0, 0);
        }

        function generateWaterscape() {
            try {
                randomSeed(params.randomSeed);
                
                // Clear canvas
                clear();
                drawBackground();
                
                // Create brushes
                let brushes = [];
                for (let i = 0; i < params.brushCount; i++) {
                    brushes.push(createWatercolorBrush());
                }
                
                // Interleave layers from different brushes for proper blending
                let totalLayers = params.layersPerBrush;
                for (let layer = 0; layer < totalLayers; layer++) {
                    for (let brush of brushes) {
                        drawWatercolorLayer(brush, layer);
                    }
                }
                
            } catch (error) {
                console.error('Generation error:', error);
            }
        }

        function drawBackground() {
            switch (params.backgroundType) {
                case 'white':
                    background(255);
                    break;
                case 'paper':
                    background(252, 248, 240);
                    drawPaperTexture();
                    break;
                case 'gradient':
                    drawGradientBackground();
                    break;
                default:
                    background(255);
            }
        }

        function drawPaperTexture() {
            noStroke();
            for (let i = 0; i < 1000; i++) {
                fill(240, 235, 220, random(5, 20));
                circle(random(width), random(height), random(0.5, 2));
            }
        }

        function drawGradientBackground() {
            for (let y = 0; y < height; y++) {
                let alpha = map(y, 0, height, 0, 1);
                let c = lerpColor(color(255, 255, 255), color(240, 248, 255), alpha);
                stroke(c);
                strokeWeight(1);
                line(0, y, width, y);
            }
        }

        // UI Functions
        function updateColorPalette() {
            const paletteDiv = document.getElementById('colorPalette');
            if (!paletteDiv) return;
            
            paletteDiv.innerHTML = '';
            
            palettes[currentPalette].forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                paletteDiv.appendChild(swatch);
            });
        }

        function setupControls() {
            // Palette selector
            const paletteSelect = document.getElementById('paletteSelect');
            if (paletteSelect) {
                paletteSelect.addEventListener('change', (e) => {
                    currentPalette = e.target.value;
                    updateColorPalette();
                    generateNew();
                });
            }

            // Parameter controls
            Object.keys(params).forEach(param => {
                const control = document.getElementById(param);
                const valueDisplay = document.getElementById(param + 'Value');
                
                if (control && valueDisplay) {
                    control.addEventListener('input', (e) => {
                        params[param] = (param === 'deformStrength' || param === 'textureIntensity') ? 
                            parseFloat(e.target.value) : 
                            parseInt(e.target.value);
                        
                        valueDisplay.textContent = 
                            (param === 'deformStrength' || param === 'textureIntensity') ? 
                            params[param].toFixed(1) : 
                            params[param];
                        
                        generateNew();
                    });
                }
            });

            // Background type
            const backgroundType = document.getElementById('backgroundType');
            if (backgroundType) {
                backgroundType.addEventListener('change', (e) => {
                    params.backgroundType = e.target.value;
                    generateNew();
                });
            }
        }

        function setup() {
            try {
                canvas = createCanvas(800, 600);
                canvas.parent('canvasWrapper');
                colorMode(RGB, 255, 255, 255, 100);
                
                setTimeout(() => {
                    setupControls();
                    updateColorPalette();
                    generateWaterscape();
                }, 100);
                
            } catch (error) {
                console.error('Setup error:', error);
            }
        }

        function generateNew() {
            if (typeof generateWaterscape === 'function') {
                generateWaterscape();
            }
        }

        function savePNG() {
            try {
                if (canvas) {
                    saveCanvas(canvas, `enhanced_waterscape_${Date.now()}`, 'png');
                }
            } catch (error) {
                console.error('Save error:', error);
                alert('Error saving image. Please try again.');
            }
        }

        function draw() {
            // Static generation
        }

        // Error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error: ' + msg + '\nURL: ' + url + '\nLine: ' + lineNo + '\nColumn: ' + columnNo + '\nError object: ', error);
            return false;
        };
    </script>
</body>
</html>