<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waterscape - Enhanced Watercolor Art</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            gap: 20px;
            padding: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            width: 350px;
            height: fit-content;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: 600;
        }

        .control-item {
            margin-bottom: 12px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
            font-weight: 500;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .control-item select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        .control-item select:focus {
            border-color: #667eea;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.secondary {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .button.secondary:hover {
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        .canvas-wrapper {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            background: white;
        }

        .value-display {
            display: inline-block;
            color: #667eea;
            font-weight: 600;
            font-size: 12px;
            margin-left: 8px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .color-swatch {
            width: 100%;
            height: 30px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.05);
            border-color: #667eea;
        }

        .color-swatch.active {
            border-color: #667eea;
            border-width: 3px;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 28px;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
                padding: 10px;
            }
            .controls {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3 style="text-align: center; margin-bottom: 20px; color: #667eea;">Enhanced Waterscape</h3>
        
        <div class="control-group">
            <h3>Color Palette</h3>
            <div class="color-palette" id="colorPalette"></div>
            <select id="paletteSelect">
                <option value="vibrant">Vibrant</option>
                <option value="pastel">Pastel</option>
                <option value="earth">Earth Tones</option>
                <option value="ocean">Ocean</option>
                <option value="sunset">Sunset</option>
                <option value="forest">Forest</option>
                <option value="monochrome">Monochrome</option>
            </select>
        </div>

        <div class="control-group">
            <h3>Watercolor Parameters</h3>
            
            <div class="control-item">
                <label for="brushCount">Brush Count: <span class="value-display" id="brushCountValue">15</span></label>
                <input type="range" id="brushCount" min="5" max="25" value="15">
            </div>

            <div class="control-item">
                <label for="layersPerBrush">Layers per Brush: <span class="value-display" id="layersPerBrushValue">30</span></label>
                <input type="range" id="layersPerBrush" min="15" max="60" value="30">
            </div>

            <div class="control-item">
                <label for="brushSize">Brush Size: <span class="value-display" id="brushSizeValue">100</span></label>
                <input type="range" id="brushSize" min="40" max="180" value="100">
            </div>

            <div class="control-item">
                <label for="edgeDetail">Edge Detail: <span class="value-display" id="edgeDetailValue">5</span></label>
                <input type="range" id="edgeDetail" min="3" max="8" value="5">
            </div>

            <div class="control-item">
                <label for="deformStrength">Deformation: <span class="value-display" id="deformStrengthValue">0.4</span></label>
                <input type="range" id="deformStrength" min="0.1" max="0.8" step="0.1" value="0.4">
            </div>

            <div class="control-item">
                <label for="opacity">Layer Opacity: <span class="value-display" id="opacityValue">6</span></label>
                <input type="range" id="opacity" min="3" max="15" value="6">
            </div>

            <div class="control-item">
                <label for="randomSeed">Random Seed: <span class="value-display" id="randomSeedValue">42</span></label>
                <input type="range" id="randomSeed" min="1" max="1000" value="42">
            </div>
        </div>

        <div class="control-group">
            <h3>Background</h3>
            <select id="backgroundType">
                <option value="white">White</option>
                <option value="paper">Paper Texture</option>
                <option value="gradient">Gradient</option>
            </select>
        </div>

        <div style="text-align: center;">
            <button class="button" onclick="generateNew()">Generate New</button>
            <button class="button secondary" onclick="savePNG()">Save PNG</button>
        </div>
    </div>

    <div class="canvas-container">
        <h1>Enhanced Waterscape</h1>
        <div class="canvas-wrapper" id="canvasWrapper"></div>
    </div>

    <script>
        // Color palettes
        const palettes = {
            vibrant: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'],
            pastel: ['#FFB3BA', '#BAFFC9', '#BAE1FF', '#FFFFBA', '#FFDFBA', '#E0BBE4', '#957DAD', '#D291BC'],
            earth: ['#8B4513', '#D2691E', '#CD853F', '#DEB887', '#F4A460', '#D2B48C', '#BC8F8F', '#A0522D'],
            ocean: ['#006994', '#4A90A4', '#83C5BE', '#7FCDCD', '#7FB3D3', '#5D737E', '#3E8E7E', '#1F4E79'],
            sunset: ['#FF4B2B', '#FF416C', '#FFA07A', '#FFB347', '#FFD700', '#FF6347', '#FF69B4', '#FF1493'],
            forest: ['#228B22', '#32CD32', '#7CFC00', '#9ACD32', '#90EE90', '#98FB98', '#00FF7F', '#3CB371'],
            monochrome: ['#2C3E50', '#34495E', '#7F8C8D', '#95A5A6', '#BDC3C7', '#D5DBDB', '#85929E', '#566573']
        };

        let currentPalette = 'vibrant';
        let params = {
            brushCount: 15,
            layersPerBrush: 30,
            brushSize: 100,
            edgeDetail: 5,
            deformStrength: 0.4,
            opacity: 6,
            randomSeed: 42,
            backgroundType: 'white'
        };

        let canvas;

        // Gaussian random function
        function gaussianRandom(mean = 0, sigma = 1) {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            let z0 = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            return z0 * sigma + mean;
        }

        // Enhanced deformation with multiple recursions
        function deformPolygonAdvanced(vertices, iterations) {
            let result = [...vertices];
            
            for (let iter = 0; iter < iterations; iter++) {
                let newVertices = [];
                
                for (let i = 0; i < result.length; i++) {
                    let current = result[i];
                    let next = result[(i + 1) % result.length];
                    
                    newVertices.push(current);
                    
                    // Create midpoint with gaussian deformation
                    let midX = (current.x + next.x) / 2;
                    let midY = (current.y + next.y) / 2;
                    
                    let strength = params.deformStrength * (20 / (iter + 1)); // Reduce strength each iteration
                    let deformX = gaussianRandom(0, strength);
                    let deformY = gaussianRandom(0, strength);
                    
                    newVertices.push({
                        x: midX + deformX,
                        y: midY + deformY
                    });
                }
                
                result = newVertices;
            }
            
            return result;
        }

        // Create enhanced watercolor brush
        function createWatercolorBrush() {
            let x = random(width * 0.15, width * 0.85);
            let y = random(height * 0.15, height * 0.85);
            let size = random(params.brushSize * 0.6, params.brushSize * 1.4);
            let sides = int(random(6, 12));
            
            // Pick random color
            let colorIndex = int(random(palettes[currentPalette].length));
            let baseColor = color(palettes[currentPalette][colorIndex]);
            
            // Color variation
            let r = red(baseColor) + random(-25, 25);
            let g = green(baseColor) + random(-25, 25);
            let b = blue(baseColor) + random(-25, 25);
            
            r = constrain(r, 0, 255);
            g = constrain(g, 0, 255);
            b = constrain(b, 0, 255);
            
            // Create base polygon
            let basePolygon = [];
            for (let i = 0; i < sides; i++) {
                let angle = (TWO_PI / sides) * i;
                let vx = x + cos(angle) * size;
                let vy = y + sin(angle) * size;
                basePolygon.push({x: vx, y: vy});
            }
            
            // Apply advanced deformation
            basePolygon = deformPolygonAdvanced(basePolygon, params.edgeDetail);
            
            return {
                basePolygon: basePolygon,
                color: color(r, g, b),
                x: x,
                y: y,
                size: size
            };
        }

        // Draw single watercolor layer with texture
        function drawWatercolorLayer(brush) {
            // Create slight variation for this layer
            let layerPolygon = brush.basePolygon.map(vertex => ({
                x: vertex.x + gaussianRandom(0, 1.5),
                y: vertex.y + gaussianRandom(0, 1.5)
            }));
            
            // Additional minor deformation
            layerPolygon = deformPolygonAdvanced(layerPolygon, 2);
            
            // Set very low opacity for authentic watercolor effect
            fill(red(brush.color), green(brush.color), blue(brush.color), params.opacity);
            noStroke();
            
            // Draw the shape
            beginShape();
            for (let vertex of layerPolygon) {
                vertex(vertex.x, vertex.y);
            }
            endShape(CLOSE);
            
            // Add texture spots occasionally
            if (random() < 0.3) {
                fill(red(brush.color), green(brush.color), blue(brush.color), params.opacity * 0.5);
                for (let i = 0; i < 3; i++) {
                    let spotX = brush.x + random(-brush.size, brush.size);
                    let spotY = brush.y + random(-brush.size, brush.size);
                    let spotSize = random(1, 4);
                    circle(spotX, spotY, spotSize);
                }
            }
        }

        function generateWaterscape() {
            try {
                randomSeed(params.randomSeed);
                
                // Clear and setup
                clear();
                drawBackground();
                
                console.log("Starting generation...");
                
                // Create brushes
                let brushes = [];
                for (let i = 0; i < params.brushCount; i++) {
                    brushes.push(createWatercolorBrush());
                }
                
                console.log(`Created ${brushes.length} brushes`);
                
                // Draw layers - interleave for proper blending
                for (let layer = 0; layer < params.layersPerBrush; layer++) {
                    for (let brush of brushes) {
                        drawWatercolorLayer(brush);
                    }
                    
                    // Progress feedback
                    if (layer % 10 === 0) {
                        console.log(`Completed layer ${layer}/${params.layersPerBrush}`);
                    }
                }
                
                console.log("Generation complete!");
                
            } catch (error) {
                console.error('Generation error:', error);
                // Fallback to simple generation
                background(255);
                fill(255, 0, 0, 50);
                circle(width/2, height/2, 100);
                fill(0, 255, 0, 50);
                circle(width/2 + 50, height/2, 100);
            }
        }

        function drawBackground() {
            switch (params.backgroundType) {
                case 'white':
                    background(255);
                    break;
                case 'paper':
                    background(252, 248, 240);
                    // Simple paper texture
                    noStroke();
                    for (let i = 0; i < 500; i++) {
                        fill(240, 235, 220, random(10, 25));
                        circle(random(width), random(height), random(0.5, 2));
                    }
                    break;
                case 'gradient':
                    for (let y = 0; y < height; y++) {
                        let alpha = map(y, 0, height, 0, 1);
                        let c = lerpColor(color(255), color(240, 248, 255), alpha);
                        stroke(c);
                        strokeWeight(1);
                        line(0, y, width, y);
                    }
                    break;
                default:
                    background(255);
            }
        }

        // UI Functions
        function updateColorPalette() {
            const paletteDiv = document.getElementById('colorPalette');
            if (!paletteDiv) return;
            
            paletteDiv.innerHTML = '';
            
            palettes[currentPalette].forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                paletteDiv.appendChild(swatch);
            });
        }

        function setupControls() {
            // Palette selector
            const paletteSelect = document.getElementById('paletteSelect');
            if (paletteSelect) {
                paletteSelect.addEventListener('change', (e) => {
                    currentPalette = e.target.value;
                    updateColorPalette();
                    generateNew();
                });
            }

            // Parameter controls
            Object.keys(params).forEach(param => {
                const control = document.getElementById(param);
                const valueDisplay = document.getElementById(param + 'Value');
                
                if (control && valueDisplay) {
                    control.addEventListener('input', (e) => {
                        params[param] = param === 'deformStrength' ? 
                            parseFloat(e.target.value) : 
                            parseInt(e.target.value);
                        
                        valueDisplay.textContent = 
                            param === 'deformStrength' ? 
                            params[param].toFixed(1) : 
                            params[param];
                        
                        generateNew();
                    });
                }
            });

            // Background type
            const backgroundType = document.getElementById('backgroundType');
            if (backgroundType) {
                backgroundType.addEventListener('change', (e) => {
                    params.backgroundType = e.target.value;
                    generateNew();
                });
            }
        }

        function setup() {
            try {
                console.log("Setting up canvas...");
                canvas = createCanvas(800, 600);
                canvas.parent('canvasWrapper');
                colorMode(RGB, 255, 255, 255, 100);
                
                setTimeout(() => {
                    console.log("Setting up controls...");
                    setupControls();
                    updateColorPalette();
                    console.log("Generating initial waterscape...");
                    generateWaterscape();
                }, 100);
                
            } catch (error) {
                console.error('Setup error:', error);
            }
        }

        function generateNew() {
            console.log("Generate new called");
            if (typeof generateWaterscape === 'function') {
                generateWaterscape();
            }
        }

        function savePNG() {
            try {
                if (canvas) {
                    saveCanvas(canvas, `enhanced_waterscape_${Date.now()}`, 'png');
                }
            } catch (error) {
                console.error('Save error:', error);
                alert('Error saving image. Please try again.');
            }
        }

        function draw() {
            // Static generation
        }

        // Error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error: ' + msg + '\nURL: ' + url + '\nLine: ' + lineNo + '\nColumn: ' + columnNo + '\nError object: ', error);
            return false;
        };
    </script>
</body>
</html>